import csv
import os

from datetime import date, datetime, timedelta
import tkinter as tk
from tkinter import ttk, messagebox
import json

from tkcalendar import DateEntry

SETTINGS_FILE = "settings.json"

def load_settings():
    # Default settings
    defaults = {
        "data_file": "rain_data.csv",
        "threshold_mm": 20.0
    }

    if not os.path.exists(SETTINGS_FILE):
        return defaults

    try:
        with open(SETTINGS_FILE, "r", encoding="utf-8") as f:
            loaded = json.load(f)
    except:
        return defaults

    # Merge defaults with loaded settings
    for key, value in defaults.items():
        if key not in loaded:
            loaded[key] = value

    return loaded

def save_settings(settings):
    with open(SETTINGS_FILE, "w", encoding="utf-8") as f:
        json.dump(settings, f, indent=4)
        
DATE_FMT = "%Y-%m-%d"  # storage format

class RainApp(tk.Tk):
    def __init__(self):
        super().__init__()

        # Load settings FIRST
        self.settings = load_settings()
        # Now you can safely use settings
        self.data_file = self.settings["data_file"]
        
        self.title("Rainfall Logger")
        self.geometry("900x600")
        self.iconbitmap("rain.ico")

        self.records = []  # list of dicts

        self._build_ui()
        self._load_data()
        self._refresh_table()
        self._update_dashboard()
        
    # ---------- Data layer ----------
    def _load_data(self):
        self.records.clear()
        if not os.path.exists(self.data_file):
            return
        with open(self.data_file, newline="", encoding="utf-8") as f:
            reader = csv.DictReader(f)
            for row in reader:
                rec = {
                    "Date": row.get("Date", ""),
                    "Rain_mm": row.get("Rain_mm", ""),
                    "BOM_mm": row.get("BOM_mm", ""),
                    "Notes": row.get("Notes", ""),
                    "Watered": row.get("Watered", "No"),   # NEW
                }
                self.records.append(rec)
        self._sort_records()

    def _save_data(self):
        fieldnames = ["Date", "Rain_mm", "BOM_mm", "Notes", "Watered"]
        with open(self.data_file, "w", newline="", encoding="utf-8") as f:
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            writer.writeheader()
            for rec in self.records:
                writer.writerow(rec)

    def _sort_records(self):
        def parse_date(d):
            try:
                return datetime.strptime(d, DATE_FMT).date()
            except Exception:
                return date.min

        self.records.sort(key=lambda r: parse_date(r["Date"]))

    def _effective_mm(self, rec):
        """Return effective rainfall:
           1. Use Rain_mm if it's a number >= 0
           2. Else use BOM_mm if it's a number >= 0
           3. Else return None (invalid)
        """
        rain_raw = rec.get("Rain_mm", "").strip()
        bom_raw = rec.get("BOM_mm", "").strip()

        # Try Rain_mm first
        try:
            rain_val = float(rain_raw)
            if rain_val >= 0:
                return rain_val
        except ValueError:
            pass

        # Try BOM_mm next
        try:
            bom_val = float(bom_raw)
            if bom_val >= 0:
                return bom_val
        except ValueError:
            pass

        # Neither valid
        return None

    # ---------- UI construction ----------
    def _build_ui(self):
        # Top frame: input form
        form_frame = tk.Frame(self)
        form_frame.pack(side=tk.TOP, fill=tk.X, padx=10, pady=5)

        tk.Label(form_frame, text="Date:").grid(row=0, column=0, sticky="e")

        self.entry_date = DateEntry(
            form_frame,
            width=12,
            date_pattern="yyyy-mm-dd",   # matches your storage format
            maxdate=date.today(),        # prevents future dates in the picker
        )
        self.entry_date.grid(row=0, column=1, padx=5)

        tk.Label(form_frame, text="Rain_mm (user):").grid(row=0, column=2, sticky="e")
        self.entry_rain = tk.Entry(form_frame, width=8)
        self.entry_rain.grid(row=0, column=3, padx=5)

        tk.Label(form_frame, text="BOM_mm:").grid(row=0, column=4, sticky="e")
        self.entry_bom = tk.Entry(form_frame, width=8)
        self.entry_bom.grid(row=0, column=5, padx=5)

        tk.Label(form_frame, text="Notes:").grid(row=1, column=0, sticky="e")
        self.entry_notes = tk.Entry(form_frame, width=50)
        self.entry_notes.grid(row=1, column=1, columnspan=5, sticky="w", padx=5, pady=3)

        self.var_watered = tk.BooleanVar()
        tk.Checkbutton(form_frame, text="Watered today", variable=self.var_watered)\
            .grid(row=2, column=0, columnspan=2, sticky="w", pady=3)

        btn_add = tk.Button(form_frame, text="Add / Update", command=self._on_add_update)
        btn_add.grid(row=0, column=6, padx=10)

        btn_delete = tk.Button(form_frame, text="Delete Selected", command=self._on_delete)
        btn_delete.grid(row=1, column=6, padx=10)

        # Middle frame: table
        table_frame = tk.Frame(self)
        table_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True, padx=10, pady=5)

        columns = ("Date", "Rain_mm", "BOM_mm", "Effective_mm", "Notes", "Watered")
        self.tree = ttk.Treeview(table_frame, columns=columns, show="headings")
        for col in columns:
            self.tree.heading(col, text=col)
            self.tree.column(col, width=100 if col != "Notes" else 250, anchor="center")
            self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        scrollbar = ttk.Scrollbar(table_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscroll=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.tree.bind("<<TreeviewSelect>>", self._on_select_row)

        self.tree.tag_configure("watered", background="#90EE90")       # PaleGreen2
        self.tree.tag_configure("rain", background="#87CEFA")          # LightSkyBlue
        self.tree.tag_configure("dry", background="#FFDEAD")           # NavajoWhite
        
        # Bottom frame: dashboard
        dash_frame = tk.LabelFrame(self, text="Dashboard")
        dash_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

        # Row 0
        tk.Label(dash_frame, text="Threshold (mm):").grid(row=0, column=2, sticky="e")
        self.entry_threshold = tk.Entry(dash_frame, width=6)
        self.entry_threshold.grid(row=0, column=3, padx=5)
        self.entry_threshold.insert(0, str(self.settings["threshold_mm"]))

        # Row 1
        tk.Label(dash_frame, text="Moisture balance:").grid(row=1, column=0, sticky="e")
        self.lbl_moisture_balance = tk.Label(dash_frame, text="0.0")
        self.lbl_moisture_balance.grid(row=1, column=1, sticky="w")

        tk.Label(dash_frame, text="Watering Needed?:").grid(row=1, column=2, sticky="e")
        self.lbl_watering = tk.Label(dash_frame, text="Unknown", width=18)
        self.lbl_watering.grid(row=1, column=3, sticky="w")

        # Row 2 — Last watering date
        tk.Label(dash_frame, text="Last watering date:").grid(row=2, column=0, sticky="e")
        self.lbl_last_watering = tk.Label(dash_frame, text="-")
        self.lbl_last_watering.grid(row=2, column=1, sticky="w")

        # Row 3 — Last rainfall date + days since
        tk.Label(dash_frame, text="Last rainfall date:").grid(row=3, column=0, sticky="e")
        self.lbl_last_rain_date = tk.Label(dash_frame, text="-")
        self.lbl_last_rain_date.grid(row=3, column=1, sticky="w")

        tk.Label(dash_frame, text="Days since last rain:").grid(row=3, column=2, sticky="e")
        self.lbl_days_since = tk.Label(dash_frame, text="-")
        self.lbl_days_since.grid(row=3, column=3, sticky="w")

        # Row 4 — Missing days
        tk.Label(dash_frame, text="Missing days:").grid(row=4, column=0, sticky="e")
        self.lbl_missing = tk.Label(dash_frame, text="-")
        self.lbl_missing.grid(row=4, column=1, sticky="w")

        self.btn_show_missing = tk.Button(dash_frame, text="Show Missing Dates", command=self._show_missing_dates)
        self.btn_show_missing.grid(row=4, column=2, columnspan=2, pady=3)

        # --- Legend ---
        legend = tk.Frame(dash_frame)
        legend.grid(row=5, column=0, columnspan=4, pady=(10, 5), sticky="w")

        # Watered (overrides everything)
        tk.Label(legend, text="  ", bg="#90EE90", width=2).grid(row=0, column=0, padx=2)
        tk.Label(legend, text="Watered").grid(row=0, column=1, sticky="w", padx=(0, 10))

        # Rain > 0
        tk.Label(legend, text="  ", bg="#87CEFA", width=2).grid(row=0, column=2, padx=2)
        tk.Label(legend, text="Rain > 0 mm").grid(row=0, column=3, sticky="w", padx=(0, 10))

        # Rain = 0
        tk.Label(legend, text="  ", bg="#FFDEAD", width=2).grid(row=0, column=4, padx=2)
        tk.Label(legend, text="Rain = 0 mm").grid(row=0, column=5, sticky="w")

        # Recalculate dashboard when N or threshold changes
        self.entry_threshold.bind("<FocusOut>", lambda e: self._update_dashboard())

    # ---------- UI actions ----------
    def _on_add_update(self):
        d_str = self.entry_date.get().strip()
        rain_str = self.entry_rain.get().strip()
        bom_str = self.entry_bom.get().strip()
        notes_str = self.entry_notes.get().strip()
        watered_flag = "Yes" if self.var_watered.get() else "No"
        
        # Validate date
        try:
            d_obj = datetime.strptime(d_str, DATE_FMT).date()
        except ValueError:
            messagebox.showerror("Invalid Date", "Please enter date as YYYY-MM-DD.")
            return
        
        # Prevent future dates
        if d_obj > date.today():
            messagebox.showerror("Invalid Date", "Future dates are not allowed.")
            return

        # Validate numeric fields if not blank
        for label, val in [("Rain_mm", rain_str), ("BOM_mm", bom_str)]:
            if val != "":
                try:
                    float(val)
                except ValueError:
                    messagebox.showerror("Invalid Value", f"{label} must be a number or blank.")
                    return
                
        # Validate that at least one of Rain_mm or BOM_mm is a number >= 0
        valid_rain = False
        valid_bom = False

        try:
            if rain_str != "":
                if float(rain_str) >= 0:
                    valid_rain = True
        except ValueError:
            pass

        try:
            if bom_str != "":
                if float(bom_str) >= 0:
                    valid_bom = True
        except ValueError:
            pass

        if not valid_rain and not valid_bom:
            messagebox.showerror(
                "Invalid Data",
                "You must enter at least one valid rainfall value (Rain_mm or BOM_mm ≥ 0)."
            )
            return

        # Upsert by date (one record per date)
        found = False
        for rec in self.records:
            if rec["Date"] == d_obj.strftime(DATE_FMT):
                rec["Rain_mm"] = rain_str
                rec["BOM_mm"] = bom_str
                rec["Notes"] = notes_str
                rec["Watered"] = watered_flag     # NEW
                found = True
                break
        if not found:
            self.records.append({
                "Date": d_obj.strftime(DATE_FMT),
                "Rain_mm": rain_str,
                "BOM_mm": bom_str,
                "Notes": notes_str,
                "Watered": watered_flag,       # NEW
            })

        self._sort_records()
        self._save_data()
        self._refresh_table()
        self._update_dashboard()

    def _on_delete(self):
        sel = self.tree.selection()
        if not sel:
            return
        item_id = sel[0]
        values = self.tree.item(item_id, "values")
        d_str = values[0]
        self.records = [r for r in self.records if r["Date"] != d_str]
        self._save_data()
        self._refresh_table()
        self._update_dashboard()

    def _on_select_row(self, event):
        sel = self.tree.selection()
        if not sel:
            return
        item_id = sel[0]
        values = self.tree.item(item_id, "values")
        self.entry_date.delete(0, tk.END)
        self.entry_date.insert(0, values[0])
        self.entry_rain.delete(0, tk.END)
        self.entry_rain.insert(0, values[1])
        self.entry_bom.delete(0, tk.END)
        self.entry_bom.insert(0, values[2])
        self.entry_notes.delete(0, tk.END)
        self.entry_notes.insert(0, values[4])

    # ---------- Table & dashboard refresh ----------

    def _refresh_table(self):
        for row in self.tree.get_children():
            self.tree.delete(row)

        for rec in self.records:
            eff = self._effective_mm(rec)
            eff_str = "" if eff is None else f"{eff:.1f}"

            # Determine tag priority
            if rec.get("Watered", "No") == "Yes":
                tags = ("watered",)
            else:
                if eff is None:
                    tags = ()  # invalid data, no colour
                elif eff > 0:
                    tags = ("rain",)
                else:
                    tags = ("dry",)

            self.tree.insert(
                "",
                tk.END,
                values=(
                    rec["Date"],
                    rec["Rain_mm"],
                    rec["BOM_mm"],
                    eff_str,
                    rec["Notes"],
                    rec["Watered"],
                ),
                tags=tags
            )
            
        # ✅ Scroll to the bottom so latest entries are visible
        self.tree.yview_moveto(1.0)

    def _update_dashboard(self):

        # --- Threshold (mm) ---
        try:
            threshold = float(self.entry_threshold.get())
        except ValueError:
            threshold = 20.0
            self.entry_threshold.delete(0, tk.END)
            self.entry_threshold.insert(0, "10")

        # Save updated threshold only
        self.settings["threshold_mm"] = threshold
        save_settings(self.settings)

        # --- Moisture balance since last watering ---
        balance = 0.0
        today = date.today()
        last_watering_date = None
        last_rain_date = None

        for rec in self.records:
            # Parse date
            try:
                d_obj = datetime.strptime(rec["Date"], DATE_FMT).date()
            except ValueError:
                continue

            # Effective rainfall
            eff = self._effective_mm(rec)
            if eff is None:
                continue

            # Track last rainfall date
            if eff > 0:
                if last_rain_date is None or d_obj > last_rain_date:
                    last_rain_date = d_obj

            # Add rainfall to moisture balance
            balance += eff

            # Reset if watering was done
            if rec.get("Watered", "No") == "Yes":
                last_watering_date = d_obj
                balance = 0.0

        # --- Update dashboard labels ---

        # Moisture balance
        self.lbl_moisture_balance.config(text=f"{balance:.1f} mm")

        # Watering needed?
        if balance < threshold:
            self.lbl_watering.config(text="YES – Water Lawn", bg="red", fg="white")
        else:
            self.lbl_watering.config(text="No watering needed", bg="green", fg="white")

        # Last watering date
        if last_watering_date is None:
            self.lbl_last_watering.config(text="-")
        else:
            self.lbl_last_watering.config(text=last_watering_date.strftime(DATE_FMT))

        # Last rainfall date + days since
        if last_rain_date is None:
            self.lbl_last_rain_date.config(text="-")
            self.lbl_days_since.config(text="-")
        else:
            self.lbl_last_rain_date.config(text=last_rain_date.strftime(DATE_FMT))
            self.lbl_days_since.config(text=str((today - last_rain_date).days))

        # Missing days detector
        missing = self._compute_missing_dates()

        if missing:
            self.lbl_missing.config(text="Missing days detected")
            self.btn_show_missing.grid()   # show button
        else:
            self.lbl_missing.config(text="No missing days")
            self.btn_show_missing.grid_remove()   # hide button

    def _compute_missing_dates(self):
        """Return list of missing dates (as date objects) between min and max Date."""
        if not self.records:
            return []

        dates = []
        for rec in self.records:
            try:
                d_obj = datetime.strptime(rec["Date"], DATE_FMT).date()
                dates.append(d_obj)
            except ValueError:
                continue
        if not dates:
            return []

        dates = sorted(set(dates))
        all_dates = []
        d = dates[0]
        while d <= dates[-1]:
            all_dates.append(d)
            d += timedelta(days=1)

        existing = set(dates)
        missing = [d for d in all_dates if d not in existing]
        return missing

    def _show_missing_dates(self):
        missing = self._compute_missing_dates()
        if not missing:
            messagebox.showinfo("Missing Dates", "No missing days.")
            return

        win = tk.Toplevel(self)
        win.title("Missing Dates")
        txt = tk.Text(win, width=20, height=15)
        txt.pack(fill=tk.BOTH, expand=True)
        for d in missing:
            txt.insert(tk.END, d.strftime(DATE_FMT) + "\n")
        txt.config(state="disabled")


if __name__ == "__main__":
    app = RainApp()
    app.mainloop()
